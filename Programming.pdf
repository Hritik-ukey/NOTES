Reverse a number...

| Expression   | Meaning                | Result (for n = 4554) |
| ------------ | ---------------------- | --------------------- |
| `n = n % 10` | Gets the last digit    | 4                     |
| `n = n / 10` | Removes the last digit | 455                   |
-------------------------------------------------------------------

  int rev=0;
  while(n>0){
   int ld = n%10;
   rev = (rev*10)+ln;
   n=n/10;
   }
--------------------
   int n, rev = 0;
    cin >> n;
    
    while (n > 0) {
        int ln = n % 10;
        rev = (rev * 10) + ln;
        n = n / 10;
    }

    cout << "Reversed number: " << rev << endl;

  TC : O(Log N)
  SC : O(1)
---------------------------------------------------------------------
Square Root :

int n = 5;
cout<<sqrt(n);

TC: O(1)
SC: O(1)

or

int n=5;
int i=0;
while(i*i<=5){
   i++;
}

cout<<i-1;


or
TC : sqrt(n)
SC : O(1)
---------------------------------------------------------------------

Fibbonacci Series....

int n=6;

    int first=0,second=1;
    for(int i=0;i<n;i++){
      cout<<first<<" ";
      int c = first+second;
      first=second;
      second=c; 
    }

O(n)

  if(n == 0 || n == 1)
      return 1;
      return Fibonacchi(n-1)+Fibonacchi(n-2);


      for(int i=0;i<=n;i++){
        cout<<Fibbonacci(i);
      }

      0(2^n)
-------------------------------------------------
BINARY SEARCH :

string toBinary(long long n){
  if(n==0) return "0";
  if(n==1) return "1";
  
  return toBinary(n>>1) + ((n&1) ? "1" : "0");
}
int main
    long long n=10;
    cout<<"Binary: "<<toBinary(n);

-------------------------------------------------
Square root :

     int number;
     cin>>number;
     int ans = sqrt(number);
     cout<<"Your Square root is : "<<ans;

     O(n log n).

     OR

     for(i=1;i<=n;i++){
      if(i*i<=n){
        ans=i;
      }
      else{
        break;
      }
     }
   
     O(n)

     OR 

     Minimal ans = 1 highest = n;
   
     int low = 1 , high = n;
     while(low<=high){
      int mid = low + (high-low) / 2;
      int value = (mid*mid);

      if(value<=n){
        low = mid+1;
      }
      else{
        high = mid - 1;
      }
      return high;
     }
--------------------------------------------------------------------
long long factorial(int n) {
    long long res = 1;
    for(int i = 2; i <= n; i++) res *= i;
    return res;
}


int fib(int n) {
    if(n <= 1) return n;
    int a = 0, b = 1;
    for(int i = 2; i <= n; i++) {
        int c = a + b;
        a = b;
        b = c;
    }
    return b;
}
  üïí Time: O(n)
üß† Space: O(1)
----------------------------------------------------------------------
Reverse Number

#include <bits/stdc++.h>
using namespace std;

bool ispalindrome(int n){
    int rev=0,dup=n;
    while(n>0){
        int ln=n%10;
        rev=(rev*10)+ln;
        n=n/10;
    }
    return dup == rev;
}
int main()
{
    int n = 4554;
    cout<<(ispalindrome(n) ? "Yes" : "No");
    return 0;
}
---------------------------------------------------------------------
Armastrong Number :

Input:153
Output: Yes
Explanation: 153 is an Armstrong number, 1*1*1 + 5*5*5 + 3*3*3 = 153

- 1 and 9 ‚Üí log10(num) is between 0 and 1
- 10 and 99 ‚Üí log10(num) is between 1 and 2
- 100 and 999 ‚Üí log10(num) will be between 2 and 3



#include <bits/stdc++.h>
using namespace std;

bool isArmstrong(int num) {
    int sum = 0, temp = num, n = log10(num) + 1;
    while (temp) {
        sum += pow(temp % 10, n);
        temp /= 10;
    }
    return sum == num;
}

int main()
{
    int num;
    cin >> num;
    cout << (isArmstrong(num) ? "Armstrong" : "Not Armstrong") << endl;

    return 0;
}

TC : O(N LOG N) sum = logn . n times looping
SC : O(1)

---------------------------------------------------------------------
ALL Permutation :

do {
        for (int i = 0; i < n; i++) cout << arr[i] << " ";
        cout << endl;
    } while (next_permutation(arr, arr + n));


Next Permutation :

 int arr[] = {1,3,2};
    next_permutation(arr,arr+3);
    cout<<arr[0]<<" "<<arr[1]<<" "<<arr[2]<<endl;

TC : O(n*n!)  next_permutation = O(N) looping n!
SC : O(1)
---------------------------------------------------------------------
Remove Duplicates O(N LOG N) through sets

#include <bits/stdc++.h>
using namespace std;

void removeduplicates(int arr[],int n){
    set<int> s;
    
    for(int i=0;i<n;i++){
        s.insert(arr[i]);
    }
    for(auto it:s){
        cout<<it<<" ";
    }
}
int main() {
    
    int arr[] = {1,2,2,3,4,4,5};
    int n = sizeof(arr)/sizeof(int);
    
    removeduplicates(arr,n);
    
    return 0;
}

TC : - insertion into s (LOG N) but N elements -> O(N LOG N)
SC : - The set stores at most n unique elements ‚Üí O(n)



Remove without sets O(Log N) and O(1)

OR 

#include <bits/stdc++.h>
using namespace std;

int removeduplicates(int arr[], int n) {
    if (n == 0) return 0;

    int i = 0; // Pointer for unique elements

    for (int j = 1; j < n; j++) {
        if (arr[j] != arr[i]) {  // Found a unique element
            i++;
            arr[i] = arr[j];  // Move it forward
        }
    }
    return i + 1;  // Length of unique elements
}

int main() {
    int arr[] = {1, 2, 2, 3, 4, 4, 5}; // Sorted array required
    int n = sizeof(arr) / sizeof(arr[0]);

    int newLength = removeduplicates(arr, n);

    for (int i = 0; i < newLength; i++) {
        cout << arr[i] << " ";
    }

    return 0;
}
------------------------------------------------------------------------
Two Pair Sum :

  unordered_set<int> s;

    for (int i = 0; i < arr.size(); i++){
        int complement = target - arr[i];

        if (s.find(complement) != s.end())
            return true;

        s.insert(arr[i]);
    }
  
    return false;
{1 2 3 4 5}

5-1=4
s={}

5-2=3
s={1}

5-3=2
s={1,2}

TC : O(LOG N)
SC : O(1)
---------------------------------------------------------------------------------

MAXIMUM SUBARRAY SUM

 // C++ program to find maximum product subarray
#include <bits/stdc++.h>
using namespace std;

// Function to find maximum product subarray
int maxProduct(int* arr, int n)
{
    // Variables to store maximum and minimum
    // product till ith index.
    int minVal = arr[0];
    int maxVal = arr[0];

    int maxProduct = arr[0];

    for (int i = 1; i < n; i++) {

        // When multiplied by -ve number,
        // maxVal becomes minVal
        // and minVal becomes maxVal.
        if (arr[i] < 0)
            swap(maxVal, minVal);

        // maxVal and minVal stores the
        // product of subarray ending at arr[i].
        maxVal = max(arr[i], maxVal * arr[i]);
        minVal = min(arr[i], minVal * arr[i]);

        // Max Product of array.
        maxProduct = max(maxProduct, maxVal);
    }

    // Return maximum product found in array.
    return maxProduct;
}

// Driver Code
int main()
{
    int arr[] = { -1, -3, -10, 0, 60 };

    int n = sizeof(arr) / sizeof(arr[0]);

    cout << "Maximum Subarray product is "
         << maxProduct(arr, n) << endl;

    return 0;
}

TC : O(N)
SC : O(1)
-----------------------------------------------------------------------------------------------------------
1) Kadanes Algo
2) Min and Max
3) Second Min and Second Max
4) shifting zeros and non zeros one side
5) find particular substring in a string
6) Liked LIst :  insert beg after end
                 dlt operation
                 count no. of nodes
                 searching of element
                 reversing the list
                 arrange in asc and desc
                 linear list
                 circular list

7) arr1[1,2,3, - - -] arr2[] = {4,5,6} 
put it on on arr1[] = {1,2,3,4,5,6};

8) arr[0,1,0,3,2] op -> [1,3,2,0,0]
9) rotate by k steps
10) check sorted and rotated
11) mid of LL (slow and fast)
12) anagram
13) missing element
14) occurrence of nu.or char
15) sum of square root of even and odd
16) arr1 equivalent to arr2 1[3,5,2,5,2] 2[2,3,5,5,2] arr1 [3^5^2^5^2] arr2 [2^3^5^5^2]
17) best time to buy and seel
18) rearrange by sign (alternate + , -)
19) total no. of char in a string without space 
20) factorial & fibbo 
21) longest consecutive subsequence
22) Check if an array is subset of another array
----------------------------------------------------------------------------
‚úÖ 1) Kadane‚Äôs Algorithm ‚Äî Maximum Subarray Sum
    Problem: Find the contiguous subarray with the maximum sum.

iint sum=0,maxi=INT_MIN;

    for(int i=0;i<n;i++){
        sum=sum+arr[i];
        maxi=max(maxi,sum);
    }
       if(sum<0){
           sum=0;
       }
       return maxi;

‚è± Time Complexity: O(n)
üß† Space Complexity: O(1)
2,1,-3,4,-1,2,1,-5,4 = 6
---------------------------------------------------------------------------
) Maximum
int findmaxi(int arr[],int n){
    int maxi = INT_MIN;
    
    for(int i=0;i<n;i++){
        if(arr[i]>maxi){
            maxi=arr[i];
        }
    }
    return maxi;
}
---------------------------------------------------------------------------
) Second Maximum

int findmaxi(int arr[],int n){
    int maxi = INT_MIN,second_maxi=INT_MAX;
    
    for(int i=0;i<n;i++){
        maxi=max(arr[i],maxi);
        second_maxi=maxi;
        
        if(arr[i]<maxi && second_maxi < maxi){
            return second_maxi;
        }
    }
    return maxi;
}
---------------------------------------------------------------------------
‚úÖ 2) Find Min and Max in an Array
Problem: Return the minimum and maximum element in the array.

pair<int, int> findMinMax(vector<int>& arr) {
    int mini = arr[0], maxi = arr[0];
    for(int i = 1; i < arr.size(); i++) {
        mini = min(mini, arr[i]);
        maxi = max(maxi, arr[i]);
    }
    return {mini, maxi};
}

    main()

    pair<int,int> result = findmaxi(arr,n);
    cout<<result.first<<" "<<result.second;
‚è± Time Complexity: O(n)
üß† Space Complexity: O(1)
--------------------------------------------------------------------------------
‚úÖ 3) Find Second Min and Second Max
   Problem: Find the second smallest and second largest distinct elements.

pair<int, int> secondMinMax(vector<int>& arr) {
    int mini = INT_MAX, secMini = INT_MAX;
    int maxi = INT_MIN, secMaxi = INT_MIN;

    for(int x : arr) {
        if(x < mini) {
            secMini = mini;
            mini = x;
        } else if(x > mini && x < secMini) {
            secMini = x;
        }

        if(x > maxi) {
            secMaxi = maxi;
            maxi = x;
        } else if(x < maxi && x > secMaxi) {
            secMaxi = x;
        }
    }

    return {secMini, secMaxi};
}
‚è± Time Complexity: O(n)
üß† Space Complexity: O(1)
----------------------------------------------------------------------------------
 int arr[] = {5, 0, 4, 0, 1, 0, 7, 8};
    int n = sizeof(arr)/sizeof(int);
    
    sort(arr,arr+n);
    for(auto it:arr){
        cout<<it<<" ";
    } 

TC : O(N LOG N)
SC : O(1)
----------------------------------------------------------------------------------
‚úÖ 4) Shift All Zeros to End / One Side

Problem: Move all zeros to the end, maintaining order of non-zeros.

void shiftZeros(vector<int>& arr) {
    int i = 0; // Pointer for next non-zero
    for(int j = 0; j < arr.size(); j++) {
        if(arr[j] != 0) {
            swap(arr[i++], arr[j]);
        }
    }
}
‚è± Time Complexity: O(n)
üß† Space Complexity: O(1)

---------------------------------------------------------------------------------------------------
Q) 7) arr1[1,2,3, - - -] arr2[] = {4,5,6} 



void mergeSortedArrays(vector<int>& arr1, int m, vector<int>& arr2, int n) {
    int i = m - 1;       // last valid element in arr1
    int j = n - 1;       // last element in arr2
    int k = m + n - 1;   // last position in arr1

    while(i >= 0 && j >= 0) {
        if(arr1[i] > arr2[j]) {
            arr1[k--] = arr1[i--];
        } else {
            arr1[k--] = arr2[j--];
        }
    }

    // If elements left in arr2
    while(j >= 0) {
        arr1[k--] = arr2[j--];
    }
}

ime Complexity: O(m + n)
üß† Space Complexity: O(1) (in-place)
---------------------------------------------------------------------------------------------------

9) rotate by k steps
10) check sorted and rotated
11) mid of LL (slow and fast)
12) anagram
13) missing element
14) occurrence of nu.or char
15) sum of square root of even and odd


void rotate(int arr[], int n, int k) {
    k %= n;
    reverse(arr, arr + n);         // reverse the whole array
    reverse(arr, arr + k);         // reverse first k elements
    reverse(arr + k, arr + n);     // reverse remaining elements
}

 Time: O(n)
üß† Space: O(1)
----------------------------------------------------------------------------------------------------------
#include <iostream>
using namespace std;

int missingNumber(int arr[], int n) {
    int total = n * (n + 1) / 2;
    int sum = 0;
    for(int i = 0; i < n - 1; i++)
        sum += arr[i];
    return total - sum;
}

int main() {
    int arr[] = {1, 2, 4, 5};
    int n = 5; // Total count including the missing number
    int missing = missingNumber(arr, n);
    cout << "Missing number is: " << missing << endl;
    return 0;
}
üïí Time: O(n)
üß† Space: O(1)
----------------------------------------------------------------------------------------------------------

// C++ program to check if two integer arrays are equivalent
// using XOR logic (assumes all elements are unique)

#include <iostream>
using namespace std;

bool areEquivalent(int arr1[], int arr2[], int n, int m) {
    if (n != m) return false;

    int xor1 = 0, xor2 = 0;
    for (int i = 0; i < n; i++) xor1 ^= arr1[i];
    for (int i = 0; i < m; i++) xor2 ^= arr2[i];

    return xor1 == xor2;
}

int main() {
    int arr1[] = {1, 2, 3, 4, 5};
    int arr2[] = {5, 4, 3, 2, 1};
    int n = sizeof(arr1) / sizeof(int);
    int m = sizeof(arr2) / sizeof(int);

    if (areEquivalent(arr1, arr2, n, m)) {
        cout << "Yes";
    } else {
        cout << "No";
    }

    return 0;
}

 Time: O(n)
üß† Space: O(n)
-----------------------------------------------------------------------------------

int maxProfit(vector<int>& prices) {
    int minPrice = INT_MAX, maxProfit = 0;
    for(int price : prices) {
        minPrice = min(minPrice, price);
        maxProfit = max(maxProfit, price - minPrice);
    }
    return maxProfit;
}
 Time: O(n)
üß† Space: O(1)
100, 180, 260,310, 40, 535, 695    = 865
------------------------------------------------------------------------------------------
Container with most water

Input: height = [1,8,6,2,5,4,8,3,7]
Output: 49
Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. 
In this case, the max area of water (blue section) the container can contain is 49.
Example 2:

Input: height = [1,1]
Output: 1

class Solution {
public:
    int maxArea(vector<int>& height) {
        int left = 0, right = height.size() - 1;
        int maxarea = 0;
        while (left < right) {
            int h = min(height[left], height[right]);
            int area = h * (right - left);
            maxarea = max(maxarea, area);
            if (height[left] < height[right]) {
                ++left;
            } else {
                --right;
            }
        }
        return maxarea;
    }
};
------------------------------------------------------------------------------------------
#include <vector>
#include <algorithm>
using namespace std;

vector<vector<int>> threeSum(vector<int>& nums) {
    sort(nums.begin(), nums.end());  // Step 1: Sort the array
    vector<vector<int>> result;
    int n = nums.size();

    for (int i = 0; i < n - 2; ++i) {
        // Skip duplicate elements for the first number
        if (i > 0 && nums[i] == nums[i - 1]) continue;

        int left = i + 1;
        int right = n - 1;

        while (left < right) {
            int sum = nums[i] + nums[left] + nums[right];

            if (sum < 0)
                ++left;
            else if (sum > 0)
                --right;
            else {
                result.push_back({nums[i], nums[left], nums[right]});
                // Skip duplicates for left and right
                while (left < right && nums[left] == nums[left + 1]) ++left;
                while (left < right && nums[right] == nums[right - 1]) --right;
                ++left;
                --right;
            }
        }
    }
    return result;
}
 tc : O(n¬≤)
 sc : O(1)
------------------------------------------------------------------------------------------
#include <vector>
using namespace std;

vector<int> spiralOrder(const vector<vector<int>>& matrix) {
    vector<int> res;
    if (matrix.empty()) return res;

    int top = 0, bottom = matrix.size() - 1;
    int left = 0, right = matrix[0].size() - 1;

    while (top <= bottom && left <= right) {
        // Move right
        for (int i = left; i <= right; ++i)
            res.push_back(matrix[top][i]);
        ++top;

        // Move down
        for (int i = top; i <= bottom; ++i)
            res.push_back(matrix[i][right]);
        --right;

        // Move left
        if (top <= bottom) {
            for (int i = right; i >= left; --i)
                res.push_back(matrix[bottom][i]);
            --bottom;
        }

        // Move up
        if (left <= right) {
            for (int i = bottom; i >= top; --i)
                res.push_back(matrix[i][left]);
            ++left;
        }
    }

    return res;
}
 TC :  O(m √ó n)
 SC : O(1)
------------------------------------------------------------------------------------------
 #include <vector>
using namespace std;

void rotate(vector<vector<int>>& matrix) {
    int n = matrix.size();

    // Step 1: Transpose (swap matrix[i][j] with matrix[j][i])
    for (int i = 0; i < n; ++i)
        for (int j = i + 1; j < n; ++j)
            swap(matrix[i][j], matrix[j][i]);

    // Step 2: Reverse each row
    for (int i = 0; i < n; ++i)
        reverse(matrix[i].begin(), matrix[i].end());
}
 
 O(n¬≤) time sc O(1)

------------------------------------------------------------------------------------------
#include <vector>
using namespace std;

void setZeroes(vector<vector<int>>& matrix) {
    int m = matrix.size(), n = matrix[0].size();
    bool firstRowZero = false, firstColZero = false;

    // Check if first row and first column need to be zeroed
    for (int i = 0; i < m; ++i)
        if (matrix[i][0] == 0)
            firstColZero = true;
    for (int j = 0; j < n; ++j)
        if (matrix[0][j] == 0)
            firstRowZero = true;

    // Use first row and column as markers
    for (int i = 1; i < m; ++i)
        for (int j = 1; j < n; ++j)
            if (matrix[i][j] == 0)
                matrix[i][0] = matrix[0][j] = 0;

    // Zero out cells based on markers
    for (int i = 1; i < m; ++i)
        for (int j = 1; j < n; ++j)
            if (matrix[i][0] == 0 || matrix[0][j] == 0)
                matrix[i][j] = 0;

    // Zero first column if needed
    if (firstColZero)
        for (int i = 0; i < m; ++i)
            matrix[i][0] = 0;

    // Zero first row if needed
    if (firstRowZero)
        for (int j = 0; j < n; ++j)
            matrix[0][j] = 0;
}

 TC :  O(m √ó n)
 SC : O(1)
------------------------------------------------------------------------------------------
vector<int> rearrangeBySign(vector<int>& nums) {
    vector<int> pos, neg;
    for(int x : nums) {
        if(x >= 0) pos.push_back(x);
        else neg.push_back(x);
    }

    vector<int> res;
    int i = 0;
    while(i < pos.size() || i < neg.size()) {
        if(i < pos.size()) res.push_back(pos[i]);
        if(i < neg.size()) res.push_back(neg[i]);
        i++;
    }
    return res;
}

üïí Time: O(n)
üß† Space: O(n)
------------------------------------------------------------------------------------------------
) Longest consecutive subsequence 
Input:  nums = [100, 4, 200, 1, 3, 2]
Output: 4
Explanation: The longest consecutive sequence is [1, 2, 3, 4]

class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        unordered_set<int> numSet(nums.begin(), nums.end());
        int longest = 0;

        for (int num : numSet) {
            // Only start counting if it's the beginning of a sequence
            if (!numSet.count(num - 1)) {
                int current = num;
                int streak = 1;

                while (numSet.count(current + 1)) {
                    current++;
                    streak++;
                }

                longest = max(longest, streak);
            }
        }

        return longest;
    }
};
----------------------------------------------------------------------------------------------------------
)bool checkSortedRotated(vector<int>& arr) {
    int count = 0, n = arr.size();
    for(int i = 0; i < n; i++) {
        if(arr[i] > arr[(i+1)%n])
            count++;
    }
    return count <= 1;
}
Time: O(n)
üß† Space: O(1)
----------------------------------------------------------------------------------------------------------
‚úÖ 5) Find a Particular Substring in a String

    string txt = "geeksforgeeks";
    string pat = "eks";
   
    int idx = txt.find(pat);
  
    if(idx != string::npos)
        cout << "yes";
    else
        cout << "No";
---------------------------------------------------------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

void numberofoccurences(string str,int n) {
    unordered_map<char,int> mp;
    
    for(int i=0;i<n;i++){
        mp[str[i]]++;
    }
    
    for(auto it:mp){
        cout<<it.first<<" "<<it.second<<endl;
    }
}
int main()
{
    string str = "String";
    int n = str.length();
    
    numberofoccurences(str,n);

    return 0;
}
---------------------------------------------------------------------------------------------------------------


#include <bits/stdc++.h>
using namespace std;

bool isAnagram(string str1,string str2){
    if(str1.length()!=str2.length()) return false;
    
    sort(str1.begin(),str1.end());
    sort(str2.begin(),str2.end());
    
    for(int i=0;i<str1.length()-1;i++){
        if(str1[i] !=str2[i]){
            return false;
        }
    }
    return true;
}

int main()
{
    string str1 = "String";
    string str2 = "ingrtS";
    int n = str1.length();
    int m = str2.length();
    
    if(isAnagram(str1,str2)){
        cout<<"Yes";
    }
    else{
        cout<<"No";
    }

    return 0;
}

O(NLogN)

-----------------------------------------------------------------------------------------------------
string text = "Hello, world!";
    string keyword = "world";

    if (text.find(keyword) != string::npos) {
        cout << "Substring found!" << endl;
    }
    else {
        cout << "Substring not found!" << endl;
    }
------------------------------------------------------------------------------------------------------------
Q) count length of words  
   
   Pogramming Question : 
   1) No. Of Occurence of Word
   
   string text = "Hellow Dosto kaise ho aap sab";
    map<string,int> wordcount;
    istringstream iss(text); //Stream break string by spaces
    string word;

    while(iss >> word){  //cin>>x; Hellow Dosto kaise ho
        wordcount[word]++;
    }

    //iss = istringstream creates a stream on string 
    //>> word = stream se ek ek word nikalta hai like e.g, cin>> 

    for(auto it:wordcount){
        cout<<it.first<<" "<<it.second<<endl;
    }


   2) Given a two digit number, return a new number which is formed by the string combination of squares of individual numbers.
    Input 82
    output 64+4=82
    
    int num;
    cin>>num;


    int first = num/10;
    int second = num%10;

    int square1 = first * first;
    int square2 = second*second;

    cout<<square1<<" "<<square2<<endl;

---------------------------------------------------------------------------------------------------------------------------------
print Hellow to hellow
   
    transform(word.begin(),word.end(),word.begin(), ::tolower);
    
Reverse String :
    reverse(str.begin(),str.end());
OR
 //Reversing name

    string str = "Hritik";
    int l=0;
    int r = str.length()-1;

    while(l<=r){
        swap(str[l++],str[r--]);
    }
    cout<<str;
--------------------------------------------------------------------------------------------------------------------------------
) No of char Freq

#include <iostream>
#include <unordered_map>
using namespace std;

void characterFrequency(const string& s) {
    unordered_map<char, int> freq;

    for (char ch : s) {
        freq[ch]++;
    }

    for (const auto& entry : freq) {
        cout << entry.first << " : " << entry.second << endl;
    }
}

int main() {
    string input = "hello world";
    characterFrequency(input);
    return 0;
}
 --------------------------------------------------------------------------------------------------------------------------------
 )  Ransom Note

 Input: ransomNote = "aa", magazine = "aab"
 Output: true

class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        // Create an array to store frequencies of each lowercase letter
        // Index 0 corresponds to 'a', 1 to 'b', ..., 25 to 'z'
        int freq[26] = {0};

        // Count the frequency of each character in the magazine
        for (char c : magazine) {
            freq[c - 'a']++; // Increment count for the letter
        }

        // Check if ransomNote can be constructed
        for (char c : ransomNote) {
            if (freq[c - 'a'] == 0) {
                // If the letter is not available (used up or never in magazine), return false
                return false;
            }
            freq[c - 'a']--; // Use one instance of the character
        }

        // All characters in ransomNote were found in magazine
        return true;
    }
};

 --------------------------------------------------------------------------------------------------------------------------------
   3) If we have the String like "The java programming" we will print consonants and vowels at the end and with not repeating 
      consonants/vowels

 bool isvowel(char ch){
    ch =tolower(ch);
    return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u';



string str = "This is java programme";
    
    set<char> seen;
    string vowel = "", consonant = "";

    for (auto ch : str) {
        ch = tolower(ch);
        if (ch == ' ' || seen.count(ch)) continue;

        if (isalpha(ch)) {
            seen.insert(ch);
            if (isVowel(ch))
                vowel += ch;
            else
                consonant += ch;
        }
    }

    cout << "Vowels: " << vowel << endl;
    cout << "Consonants: " << consonant << endl;
-----------------------------------------------------------
   4) Sort the numbers both asc and desc order

    int n,x;
    cin>>n;
    vector<int> nums;
    for(int i=0;i<n;i++){
        cin>>x;
        nums.push_back(x);
    }
    cout<<"Ascending Order..."<<endl;
    
    sort(nums.begin(),nums.end());
    for(auto it : nums){
        cout<<it<<" "<<;
    }
    
    cout<<"Descending Order..."<<endl;

   sort(nums.rbegin(),nums.rend());
   for(auto it : nums){
       cout<<it<<" ";
   }
   ------------------------------------------------------------ 
#include <iostream>
#include <string>
using namespace std;

int longestConsecutiveSubstring(const string& str) {
    if (str.empty()) return 0;

    int maxLen = 1, currLen = 1;

    for (int i = 1; i < str.length(); ++i) {
        if (str[i] - str[i - 1] == 1) {
            currLen++;
            maxLen = max(maxLen, currLen);
        } else {
            currLen = 1;
        }
    }

    return maxLen;
}

int main() {
    string str = "abcabcdefabc";
    int result = longestConsecutiveSubstring(str);
    cout << "Length of the longest substring with consecutive characters: " << result << endl;
    return 0;
}

 Time: O(n)
üß† Space: O(1)
----------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------

----------------------------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

string longestprefix(vector<string> &str){
    if (str.empty()) return "";
    
    string prefix = str[0];
    for(int i=1;i<str.size();i++){
        while(str[i].find(prefix)!=0){
            prefix=prefix.substr(0,prefix.size()-1);
        }
    }
    return prefix;
}

int main()
{
    vector<string> arr = {"geeksforgeeks", "geeks", "geek", "geezer"}; 
    cout<<"longest common prefix : "<<longestprefix(arr);
    return 0;
}

O(N*M);
Through Binary search we can make it better but cant help it...

OR
if (strs.empty()) return "";

        string prefix = strs[0];
        for (int j = 1; j < strs.size(); ++j) {
            while (strs[j].find(prefix) != 0) {
                prefix = prefix.substr(0, prefix.size() - 1);
                if (prefix.empty()) return "";
            }
        }

        return prefix;
    }
------------------------------------------------------------------------------
ANAGRAM N LOG M

#include <bits/stdc++.h>
using namespace std;

bool isAnagram(string s, string t) {
    if (s.size() != t.size()) return false;
    sort(s.begin(), s.end());
    sort(t.begin(), t.end());
    return s == t;
}

int main() {
    string s = "listen", t = "silent";
    cout << (isAnagram(s, t) ? "True" : "False") << endl;
    return 0;
}

OR

 O(N)

#include <bits/stdc++.h>
using namespace std;

bool isAnagram(string s, string t) {
    if (s.size() != t.size()) return false;
    
    vector<int> count(26, 0);  
    for (char c : s) count[c - 'a']++;  
    for (char c : t) count[c - 'a']--;  
    
    return all_of(count.begin(), count.end(), [](int x) { return x == 0; });
}

int main() {
    string s = "rat", t = "tar";
    cout << (isAnagram(s, t) ? "True" : "False") << endl;
    return 0;
}
---------------------------------------------------------------------------
Check if two Strings are Anagrams of each other

// C++ Code to check if two Strings are anagrams of 
// each other using sorting

#include <algorithm>
#include <iostream>
using namespace std;

// Function to check if two strings are anagrams
bool areAnagrams(string &s1, string &s2) {
    
    // Sort both strings
    sort(s1.begin(), s1.end());
    sort(s2.begin(), s2.end());

    // Compare sorted strings
    return s1 == s2;
}

int main() {
    string s1 = "geeks";
    string s2 = "kseeg";
	cout << (areAnagrams(s1, s2) ? "true" : "false") << endl;

    return 0;
}
           O(m*log(m) + n*log(n))
----------------------------------------------------------------------------
) What is string stream 
#include <iostream>
#include <sstream>
using namespace std;

int main() {
    string s = "123 456";
    stringstream ss(s); cin ke type hota hai
    int a, b;
    ss >> a >> b;    //it means a = 123 , b = 456
    cout << a + b;  // Output: 579
    return 0;
}
    => a+b=579
----------------------------------------------------------------------------
) Even length words in a string

#include <iostream>
#include <sstream>
using namespace std;

void printEvenLengthWords(const string& s) {
    stringstream ss(s);
    string word;
    while (ss >> word) {
        if (word.length() % 2 == 0)
            cout << word << " ";
    }
}

int main() {
    string s = "I love Python and clean code";
    printEvenLengthWords(s);
    return 0;
}

love python code
O(N)
---------------------------------------------------------------------------------------
) length of last word in a string "Hellow World" World = 5;
#include <iostream>
using namespace std;

int lengthOfLastWord(const string& s) {
    int i = s.length() - 1, length = 0;

    // Skip trailing spaces
    while (i >= 0 && s[i] == ' ') i--;

    // Count length of last word
    while (i >= 0 && s[i] != ' ') {
        length++;
        i--;
    }

    return length;
}

int main() {
    string s = "Hello World";
    cout << lengthOfLastWord(s);  // Output: 5
    return 0;
}
- O(n) 

---------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------
) print number of vowels and consonants in String

#include <iostream>
#include <cctype>
using namespace std;

void countVowelsConsonants(const string& s) {
    int vowels = 0, consonants = 0;

    for (char c : s) {
        if (isalpha(c)) {
            char ch = tolower(c);
            if (ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u')
                vowels++;
            else
                consonants++;
        }
    }

    cout << "Vowels: " << vowels << endl;
    cout << "Consonants: " << consonants << endl;
}

int main() {
    string s = "Coding is fun and logical!";
    countVowelsConsonants(s);
    return 0;
}

- O(N)
- O(1)
--------------------------------------------------------------------------------------------
) Reverse words in a string
// C++ program for the above approach

#include <bits/stdc++.h>
using namespace std;

// Function to reverse the given string
string reverseString(string s){
 vector<string> words;
        string word;
        istringstream iss(s);

        while(iss >> word){
            words.push_back(word);
        }

        reverse(words.begin(),words.end());

        string result;
        for(int i=0;i<words.size();i++){
            result += words[i];
            if(i<words.size()-1) result+=" ";
        }
        return result;
    }

    TC : O(N)
    SC : O(N)

// Driver code
int main()
{
    string str = "I like this code";

    // Function call
    string rev = reverseString(str);

    // Print the reversed string
    cout << rev;
    return 0;
}

-O(N)
---------------------------------------------------------------------------------------
) No. of words 
#include <bits/stdc++.h>
using namespace std;

int countwords(string str) {
    int wordCount = 0;
    string word;
    stringstream ss(str);

    // Count words
    while (ss >> word) {
        wordCount++;
    }

    return wordCount;
}

int main() {
    string str = "Hello World Hello";
    cout << "Words ‚Üí " << countwords(str) << endl;
    return 0;
}
--------------------------------------------------------------------------------------------
) No. of Space 

#include <bits/stdc++.h>
using namespace std;

int spaceCount(string str) {
    
     int spaceCount = 0;
    for (char ch : str) {
        if (ch == ' ') {
            spaceCount++;
        }
    }

    return spaceCount;
}

int main() {
    string str = "Hello World Hello";
    cout << "space sount :  ‚Üí " << spaceCount(str) << endl;
    return 0;
}
---------------------------------------------------------------------------------------------
) NO. of words and space 

#include <bits/stdc++.h>
using namespace std;

int countWordsAndSpaces(string str) {
    int wordCount = 0;
    string word;
    stringstream ss(str);

    // Count words
    while (ss >> word) {
        wordCount++;
    }

    // Count spaces
    int spaceCount = 0;
    for (char ch : str) {
        if (ch == ' ') {
            spaceCount++;
        }
    }

    return wordCount + spaceCount;
}

int main() {
    string str = "Hello World Hello";
    cout << "Words + Spaces ‚Üí " << countWordsAndSpaces(str) << endl;
    return 0;
}
TC -> O(N)
SC -> O(1)
---------------------------------------------------------------------------------------
) Find the Index of the First Occurrence in a String

class Solution {
public:
    int strStr(string haystack, string needle) {
        int n = haystack.length();
        int m = needle.length();

        // Edge case: empty needle
        if (m == 0) return 0;

        for (int i = 0; i <= n - m; i++) {
            if (haystack.substr(i, m) == needle) {
                return i;
            }
        }

        return -1;
    }
};

tc : 0(n*m)
sc : o(1)
---------------------------------------------------------------------------------------
) Compare two string without built in

#include <iostream>
using namespace std;

bool compareStrings(const string& a, const string& b) {
    if (a.length() != b.length()) return false;

    for (int i = 0; i < a.length(); i++) {
        if (a[i] != b[i])
            return false;
    }

    return true;
}

int main() {
    string s1 = "coding", s2 = "coding";
    if (compareStrings(s1, s2))
        cout << "Strings are equal";
    else
        cout << "Strings are not equal";
    
    return 0;
}
---------------------------------------------------------------------------------------
) First non repeacting word in a string or repeting unique

 for(auto it : wordCount){
        if(it.second == 2){
            cout<<it.first<<endl;
        }
    }
       //Hellow

     for(auto it : wordCount){
        if(it.second == 1){
            cout<<it.first<<endl;
        }
    }
       //World
---------------------------------------------------------------------------------------
) Characters count in each word in a string

#include <iostream>
#include <vector>
using namespace std;

void countCharsPerWord(const string& s) {
    int count = 0;

    for (int i = 0; i <= s.length(); i++) {
        if (i < s.length() && s[i] != ' ') {
            count++;
        } else {
            if (count > 0) {
                cout << count << " ";
                count = 0;
            }
        }
    }
}

int main() {
    string s = "Hello world this is great";
    countCharsPerWord(s);  // Output: 5 5 4 2 5
    return 0;
}
-O(N)
---------------------------------------------------------------------------------------
) print number of vowels,Words,character frequency in String
#include <iostream>
#include <unordered_map>
using namespace std;

void analyzeString(const string& s) {
    int vowels = 0, words = 0;
    unordered_map<char, int> freq;
    bool inWord = false;

    for (char c : s) {
        // Count vowels
        char lower = tolower(c);
        if (lower == 'a' || lower == 'e' || lower == 'i' || lower == 'o' || lower == 'u')
            vowels++;

        // Count words
        if (c != ' ' && !inWord) {
            inWord = true;
            words++;
        } else if (c == ' ') {
            inWord = false;
        }

        // Count character frequency (ignoring spaces)
        if (c != ' ')
            freq[c]++;
    }

    // Print results
    cout << "Number of vowels: " << vowels << endl;
    cout << "Number of words: " << words << endl;
    cout << "Character frequency:\n";
    for (auto entry : freq)
        cout << "'" << entry.first << "': " << entry.second << endl;
}

int main() {
    string s = "Hello world, let's write clean code";
    analyzeString(s);
    return 0;
}

---------------------------------------------------------------------------------------
) print characters in descending order of frequency

#include <iostream>
#include <unordered_map>
#include <vector>
#include <algorithm>
using namespace std;

void printCharFrequencyDesc(const string& s) {
    unordered_map<char, int> freq;

    // Count frequency
    for (char c : s) {
        if (c != ' ') // Skip spaces, remove this line if you want to count spaces too
            freq[c]++;
    }

    // Move to vector to sort
    vector<pair<char, int>> v(freq.begin(), freq.end());

    // Sort in descending order of frequency
    sort(v.begin(), v.end(), [](pair<char, int>& a, pair<char, int>& b) {
        return a.second > b.second;
    });

    // Output
    for (auto& p : v)
        cout << "'" << p.first << "': " << p.second << endl;
}

int main() {
    string s = "coding simplified and strong";
    printCharFrequencyDesc(s);
    return 0;
}

-  Total TC = O(n + k log k
-  SC = O(k)
---------------------------------------------------------------------------------------
) find longest substring without repetition

#include <iostream>
#include <unordered_map>
using namespace std;

int lengthOfLongestSubstring(string s) {
    unordered_map<char, int> seen;
    int maxLen = 0, start = 0;

    for (int end = 0; end < s.length(); end++) {
        char curr = s[end];

        if (seen.count(curr) && seen[curr] >= start)
            start = seen[curr] + 1;

        seen[curr] = end;
        maxLen = max(maxLen, end - start + 1);
    }

    return maxLen;
}

int main() {
    string s = "abcabcbb";
    cout << lengthOfLongestSubstring(s);  // Output: 3 ("abc")
    return 0;
}


-O(N)
-O(K)
---------------------------------------------------------------------------------------
) check given String is Panagram or not  (A to Z all characters)

#include <iostream>
#include <cctype>
#include <unordered_set>
using namespace std;

bool isPangram(const string& s) {
    unordered_set<char> letters;

    for (char c : s) {
        if (isalpha(c))
            letters.insert(tolower(c));
    }

    return letters.size() == 26;
}

int main() {
    string s = "The quick brown fox jumps over the lazy dog";
    if (isPangram(s))
        cout << "It's a pangram" << endl;
    else
        cout << "Not a pangram" << endl;

    return 0;
}  

o(n)
o(1)
---------------------------------------------------------------------------------------
All Possible subsquence...

#include <bits/stdc++.h>
using namespace std;

void printSubsequences(string s, string current, int index) {
    if (index == s.length()) {
        cout << (current.empty() ? "Œµ" : current) << endl;
        return;
    }
    or
     //         if (i == s.size()) {
     //         if (result == "")
      //             cout << "Œµ" << endl;  // shows the empty subsequence
    //         else
     //             cout << result << endl;
        //         return;
          //     }

    // Option 1: Include current character
    printSubsequences(s, current + s[index], index + 1);

    // Option 2: Exclude current character
    printSubsequences(s, current, index + 1);
}

int main() {
    string s = "abc";
    cout << "All possible subsequences are:" << endl;
    printSubsequences(s, "", 0);
    return 0;
}

O(2^N)
---------------------------------------------------------------------------------------
Z pattern


#include <bits/stdc++.h>
using namespace std;

void findPattern(string text, string pattern) {
    int n = text.size();
    int m = pattern.size();  
    
    for (int i = 0; i <= n - m; i++) {
        if (text.substr(i, m) == pattern) {
            cout << i << " ";
        }
    }
    cout << endl;
}

int main() {
    string text = "xyzabxyzabxyz";
    string pattern = "xyz";

    findPattern(text, pattern);
    
    return 0;
}

O(NM)
--------------------------------------------------------------------------------------
Rotation of one another

// C++ program to check if two given strings
// are rotations of  each other
#include <iostream>
using namespace std;

// Function to check if s1 and s2 are rotations of each other
bool areRotations(string &s1, string &s2) {
  	s1 += s1;
  
  	// find s2 in concatenated string
  	return s1.find(s2) != string::npos;
}

int main() {
    string s1 = "aab"; 
    string s2 = "aba";
  	
    cout << (areRotations(s1, s2) ? "true" : "false");
}

------------------------------------------------------------------
Valid suffle or not :

#include <iostream>
#include <string>
#include <unordered_map>
using namespace std;

bool isValidShuffle(const string& str1, const string& str2) {
    if (str2.length() != 2 * str1.length())
        return false;

    unordered_map<char, int> freq;
    for (char c : str1) freq[c] += 2; // Since str1 occurs twice
 
   //coz freq of str1+str1 = str2

    for (char c : str2) {
        if (freq[c] == 0) return false;  //if extra char a part from str1+str1 occur then false
        freq[c]--;     // No extra no missing
    }
    return true;
}

int main() {
    string str1 = "geekforgeeks";
    string str2 = "ekegorfkeegsgeek";

    cout << (isValidShuffle(str1, str2) ? "Valid Shuffle" : "Not a Valid Shuffle") << endl;
    return 0;
}

O(N)
O(1)
-------------------------------------------------------------------------
Print all Subsequences of a string.

#include <iostream>
using namespace std;

void generateSubsequences(string s, string curr, int index) {
    if (index == s.size()) {
        cout << "\"" << curr << "\", ";
        return;
    }

    // Include the current character
    generateSubsequences(s, curr + s[index], index + 1);
    
    // Exclude the current character
    generateSubsequences(s, curr, index + 1);
}

int main() {
    string s = "ab";
    cout << "Output: ";
    generateSubsequences(s, "", 0);
    return 0;
}
   O(2^N)
   O(N)
------------------------------------------------------------------------
Permutations of the given string : 

#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

void printPermutations(string s) {
    sort(s.begin(), s.end()); // Ensure lexicographical order
    do {
        cout << s << ", ";
    } while (next_permutation(s.begin(), s.end()));
}

int main() {
    string s = "ABC";
    printPermutations(s); // Output: "ABC", "ACB", "BAC", "BCA", "CAB", "CBA"
    return 0;
}
- Time Complexity: O(N!)
- Space Complexity: O(1) 


OR  

#include <iostream>
#include <algorithm>

using namespace std;

void generatePermutations(string &s, int l, int r) {
    if (l == r) {
        cout << s << ", ";
        return;
    }

    for (int i = l; i <= r; i++) {
        swap(s[l], s[i]);
        generatePermutations(s, l + 1, r);
        swap(s[l], s[i]); // Backtrack to restore original order
    }
}

int main() {
    string s = "ABC";
    sort(s.begin(), s.end()); // Ensure initial lexicographical order
    generatePermutations(s, 0, s.size() - 1);
    return 0;
}
- Time Complexity: O(N!)
- Space Complexity: O(1) 

------------------------------------------------------------------------------

#include <iostream>
#include <algorithm>

using namespace std;

string nextGreaterNumber(string num) {
    int n = num.size();
    
    // Step 1: Find the rightmost smaller digit
    int i = n - 2;
    while (i >= 0 && num[i] >= num[i + 1]) i--;

    if (i < 0) return "Not Possible"; // If no such digit exists, return "Not Possible"

    // Step 2: Find the smallest larger digit to swap
    int j = n - 1;
    while (num[j] <= num[i]) j--;

    swap(num[i], num[j]);

    // Step 3: Reverse the remaining digits to get the smallest arrangement
    reverse(num.begin() + i + 1, num.end());

    return num;
}

int main() {
    string num = "218765";
    cout << nextGreaterNumber(num) << endl; // Output: "251678"
    return 0;
}
    O(N)
    O(1)
--------------------------------------------------------------------------------
#include <iostream>
#include <string>

using namespace std;

// Function to check if a string is palindrome
bool isPalindrome(const string& s) {
    int left = 0, right = s.size() - 1;
    while (left < right) {
        if (s[left++] != s[right--]) return false;
    }
    return true;
}
---------------------------------------------------------------------------------
issubsequence or not 

Input: s = "abc", t = "ahbgdc"
Output: true


    bool isSubsequence(string s, string t) {
        int i = 0, j = 0;
        while (i < s.size() && j < t.size()) {
            if (s[i] == t[j]) {
                i++;
            }
            j++;
        }
        return i == s.size();
    }

---------------------------------------------------------------------------------
// Recursive function to generate subsequences
void countPalindromicSubsequences(string s, string curr, int index, int& count) {
    if (index == s.size()) {
        if (!curr.empty() && isPalindrome(curr)) count++;
        return;
    }

    // Include current character
    countPalindromicSubsequences(s, curr + s[index], index + 1, count);

    // Exclude current character
    countPalindromicSubsequences(s, curr, index + 1, count);
}

int main() {
    string s = "geeksforgeeks";
    int count = 0;
    countPalindromicSubsequences(s, "", 0, count);
    cout << count << endl; // Output: 81
    return 0;
}

----------------------------------------------------------------------------------
ALl Palindromic subscequence (Recursive)

#include <iostream>
using namespace std;

long long countPalindromicSubsequences(string& s, int i, int j) {
    if (i > j) return 0;
    if (i == j) return 1; // Single character is always a palindrome

    if (s[i] == s[j]) {
        return countPalindromicSubsequences(s, i + 1, j) + 
               countPalindromicSubsequences(s, i, j - 1) + 1;
    } else {
        return countPalindromicSubsequences(s, i + 1, j) + 
               countPalindromicSubsequences(s, i, j - 1) - 
               countPalindromicSubsequences(s, i + 1, j - 1);
    }
}

int main() {
    string s = "geeksforgeeks";
    cout << countPalindromicSubsequences(s, 0, s.size() - 1) << endl; // Output: 81
    return 0;
}

or DP
#include <iostream>
#include <vector>
using namespace std;

long long countPalindromicSubsequences(string s) {
    int n = s.size();
    vector<vector<long long>> dp(n, vector<long long>(n, 0));

    // Base case: Every single character is a palindrome
    for (int i = 0; i < n; i++) dp[i][i] = 1;

    // Fill DP table
    for (int len = 2; len <= n; len++) {
        for (int i = 0; i <= n - len; i++) {
            int j = i + len - 1;
            if (s[i] == s[j]) {
                dp[i][j] = dp[i + 1][j] + dp[i][j - 1] + 1; // Extra palindrome
            } else {
                dp[i][j] = dp[i + 1][j] + dp[i][j - 1] - dp[i + 1][j - 1]; // Remove double counted
            }
        }
    }

    return dp[0][n - 1];
}

int main() {
    string s = "geeksforgeeks";
    cout << countPalindromicSubsequences(s) << endl; // Output: 81
    return 0;
}
-----------------------------------------------------------------------------------------------------------


-----------------------------------------------------------------------------------------------------------

Implementation of LL

#include <bits/stdc++.h>
using namespace std;

struct Node {
    int data;
    Node* next;
    
    Node(int x) {
        data = x;
        next = NULL;
    }
};

// Function to print the linked list
void printList(Node* head) {
    Node* current = head;
    while (current != NULL) {
        cout << current->data << " -> ";
        current = current->next;
    }
    cout << "NULL" << endl;
}

int main() {
    Node* head = new Node(10);
    Node* first = new Node(20);
    Node* second = new Node(30);
    Node* third = new Node(40);
    
    head->next = first;
    first->next = second;
    second->next = third;
    third->next = NULL;

    // Print the linked list
    printList(head);

    return 0;
}

----------------------------------------------------------------------
Node* reverseLinkedlist(Node* head){
    Node* prev = NULL;
    Node* next = NULL;
    Node* current = head;
    
    while(current!=NULL){
        next=current->next;
        current->next = prev;
        prev=current;
        current=next;;
    }
    return prev;
}

main()
head = reverseLinkedList(head);
--------------------------------------------------------------------------
void printlinkedlist(Node* ptr){
    
    while(ptr!=NULL){
        cout<<ptr->data<<"->";
        ptr=ptr->next;
    }
    cout<<"NULL"<<endl;
}

printlinkedlist(head)
------------------------------------------
Node* insertatbeg(Node* head, int data) {
    Node* ptr = new Node(data);
    ptr->next = head;
    return ptr;
}

    head = insertatbeg(head,45);

-------------------------------------------
Node * insertAtEnd(Node *head, int data){
    Node* ptr = new Node(data);
    ptr->data = data;
    Node * p = head;

    while(p->next!=NULL){
        p = p->next;
    }
    p->next = ptr;
    ptr->next = NULL;
    return head;
}

    head = insertAtEnd(head,40);
--------------------------------------------
Node * insertAfterNode(Node *head,Node *prevNode, int data){
    Node * ptr = new Node(data);
    ptr->data = data;

    ptr->next = prevNode->next;
    prevNode->next = ptr;

    
    return head;
}
    head = insertAfterNode(head,second,22);
---------------------------------------------
Node * deleteFirst(struct Node * head){
    Node * ptr = head;
    head = head->next;
    free(ptr);
    return head;
}
    head = deleteFirst(head);
--------------------------------------------
 Node * deleteAtLast(Node * head){
    Node *p = head;
    Node *q = head->next;
    while(q->next !=NULL)
    {
        p = p->next;
        q = q->next;
    }
    
    p->next = NULL;
    free(q);
    return head;
}

   head = deleteAtLast(head);
---------------------------------------------
Node * deleteAtIndex(Node * head, int index){
    Node *p = head;
    Node *q = head->next;
    for (int i = 0; i < index-1; i++)
    {
        p = p->next;
        q = q->next;
    }
    
    p->next = q->next;
    free(q);
    return head;
}

    head = deleteAtIndex(head,1);
------------------------------------------------
    Node* head = new Node(10);
    Node* first = new Node(20);
    Node* second =new Node(30);


    head->next = first;
    first->next=second;
    second->next=NULL;
    
    printlinkedlist(head);
    head = insertatbeg(head,00);
    head = insertAfterNode(head,second,22);
    head = insertAtEnd(head,40);
    
    head = deleteFirst(head);
    head = deleteAtLast(head);
    head = deleteAtIndex(head,1);
    printlinkedlist(head);
------------------------------------------------
 Insertion beg & AfteraNodeO(1) 
 Deletion all O(1)
        
In between & end O(N)
Searching : O(N)
------------------------------------------------
ListNode* middleNode(ListNode* head) {
    ListNode *slow = head, *fast = head;
    while(fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
    }
    return slow;
}
üïí Time: O(n)
üß† Space: O(1)
-------------------------------------------------
Sliding Window Problem
